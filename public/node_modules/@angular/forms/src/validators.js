
import{OpaqueToken}from'@angular/core';import{toPromise}from'rxjs/operator/toPromise';import{StringMapWrapper}from'./facade/collection';import{isBlank,isPresent,isPromise,isString}from'./facade/lang';export var NG_VALIDATORS=new OpaqueToken('NgValidators');export var NG_ASYNC_VALIDATORS=new OpaqueToken('NgAsyncValidators');export var Validators=(function(){function Validators(){}
Validators.required=function(control){return isBlank(control.value)||(isString(control.value)&&control.value=='')?{'required':true}:null;};Validators.minLength=function(minLength){return function(control){if(isPresent(Validators.required(control)))
return null;var v=control.value;return v.length<minLength?{'minlength':{'requiredLength':minLength,'actualLength':v.length}}:null;};};Validators.maxLength=function(maxLength){return function(control){if(isPresent(Validators.required(control)))
return null;var v=control.value;return v.length>maxLength?{'maxlength':{'requiredLength':maxLength,'actualLength':v.length}}:null;};};Validators.pattern=function(pattern){return function(control){if(isPresent(Validators.required(control)))
return null;var regex=new RegExp("^"+pattern+"$");var v=control.value;return regex.test(v)?null:{'pattern':{'requiredPattern':"^"+pattern+"$",'actualValue':v}};};};Validators.nullValidator=function(c){return null;};Validators.compose=function(validators){if(isBlank(validators))
return null;var presentValidators=validators.filter(isPresent);if(presentValidators.length==0)
return null;return function(control){return _mergeErrors(_executeValidators(control,presentValidators));};};Validators.composeAsync=function(validators){if(isBlank(validators))
return null;var presentValidators=validators.filter(isPresent);if(presentValidators.length==0)
return null;return function(control){var promises=_executeAsyncValidators(control,presentValidators).map(_convertToPromise);return Promise.all(promises).then(_mergeErrors);};};return Validators;}());function _convertToPromise(obj){return isPromise(obj)?obj:toPromise.call(obj);}
function _executeValidators(control,validators){return validators.map(function(v){return v(control);});}
function _executeAsyncValidators(control,validators){return validators.map(function(v){return v(control);});}
function _mergeErrors(arrayOfErrors){var res=arrayOfErrors.reduce(function(res,errors){return isPresent(errors)?StringMapWrapper.merge(res,errors):res;},{});return StringMapWrapper.isEmpty(res)?null:res;}